<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>YDK JS Practise</title>
</head>
<body>
<script>
// Lexical Scope

/*
function foo(a){
    var b = a * 2;

    function bar(c){
        console.log(a , b, c);
    }

    bar (b * 3);
}

foo(2);
*/

// Cheating Lexical  - eval & with

// eval
/*
function foo(str, a){
    eval( str );
    console.log(a, b);
}

var b = 2;

foo("var b = 3", 1);
*/

// Using strict

/*
function foo(str){
    "use strict"
    eval( str );
    console.log(a);
}

foo("var a = 2");
*/

// with

/*
var obj = {
    a:1,
    b:2,
    c:3
}
*/

// more "tedious" to repeat "obj"
/*
obj.a = 2;
obj.b = 3;
obj.c = 4;
*/

// "easier" short hand
/*
with(obj){
    a = 3;
    b = 4;
    c = 5;
}
*/

/*
function foo(obj){
    with(obj){
        a = 2;
        // console.log(a);
    }
}

var o1 = {
    a:3
}

var o2 = {
    b:3
}

foo(o1);
console.log(o1.a);
foo(o2);
console.log(o2.a);
console.log(a);
*/

// Scope

/*
function doSomething(a){
    b = a + doSomethingElse(a * 2);
    console.log(b * 3);
}

function doSomethingElse(a){
    return a - 1;
}

var b;
doSomething( 2 );
*/

// Principle of Least Privilaged
/*
function doSomething(a){
    function doSomethingElse(a){
        return a - 1;
    }

    var b;

    b = a + doSomethingElse(a * 2);

    console.log(b * 3);
}

doSomething(2);
*/


// Collision Avoidance

/*
function foo(){
    function bar(a){
        i = 3;
        console.log( a + i);
    }

    for(var i = 0; i<10; i++){
        bar (i * 2); // infinite loop
    }
}

foo();
*/

// Global Namespaces

/*
var MyReallyCoolLibrary = {
    awesome: "stuff",
    doSomething: function (){
        // ..
    },
    doAnotherThing: function (){
        // ..
    }
}
*/

// Functions as Scopes

/*
var a = 2;

function foo(){
    var a = 3;
    console.log(a);
}
foo();
console.log(a);
*/

// Immediately Invoked Function Expression

/*
var a = 2;
(function foo(){
    var a = 3;
    console.log(a);
})();
console.log(a);
*/

// Anonymous versus Named Function

/*
// without function name
setTimeout(function (){
    console.log("I waited 1 second")
}, 1000);

// with function name
setTimeout(function timeoutHandler(){
    console.log("I waited 1 second")
}, 1000);

*/

// Invoking Function Expressions Immediately

/*
var a = 2;

(function foo(){
    var a = 3;
    console.log(a);
})();
console.log(a);

(function IIFE(){
    var a = 3;
    console.log(a);
}()); // Both are same and stylistic choice
*/

/*
var a = 2;
(function IIFE( global ){
    var a = 3;
    console.log(a);
    console.log(global.a)
})(window);
console.log(a);
*/

/*
var undefined = true;

(function IIFE( undefined ){
    var a;
    if(a === undefined){
        console.log("undefined is safe here");
    }
})();
*/

/*
var a = 2;
(function IIFE(def){
    def( window );
})(function def( global ){
    var a = 3;
    console.log(a);
    console.log(global.a);
})
*/

// Blocks as Scope

/*
for (var i = 0; i < 10; i++) {
    console.log(i);    
}

var foo = true;
if(foo){
    var bar = foo * 2;
    bar = something(bar);
    console.log(bar);
}
*/

// try/catch

/*
try{
    undefined();
}
catch(err){
    console.log(err);
}

console.log(err);
*/

/*
var foo = true;
if(foo){
    let bar = foo * 2;
    bar = something(bar);
    console.log(bar);
}
console.log(bar);
*/

/*
for (var i = 0; i < 10; i++) {
    console.log(i) 
}
console.log(i);

for (let i = 0; i < 10; i++) {
    console.log(i) 
}
console.log(i);
*/

/*
let a = 2;
function foo() {
    let a = 3;
    console.log(a);
}
foo();
console.log(a)
*/

/*
var foo = true, baz = 10;
if(foo){
    var bar = 3;

    if(baz > bar){
        console.log(baz);
    }
}
*/

// above code is refactored as

/*
var foo = true, baz = 10;
if(foo){
    var bar = 3;
}
if(baz > bar){
        console.log(baz);
}
*/

// with let
/*
var foo = true, baz = 10;
if(foo){
    let bar = 3;

    if(baz > bar){
        console.log(baz);
    }
}
*/

// Const

/*
var foo = true;
if(foo){
    var a = 2;
    const b = 3; // block scoped to the conatining if

    a = 3;
    b = 4;
}
console.log(a);
console.log(b);
*/

// Hoisting

/*
a = 2;
var a;
console.log(a);
*/

/*
console.log(a);
var a = 2;
*/

/*
foo();
function foo(){
    console.log(a);
    var a = 2;
}
*/

/*
foo();
var foo;
function foo() {
    console.log(1);
}
foo = function () {
    console.log(2)
}
*/

/*
function foo() {
    console.log(1);
}
foo();
foo = function () {
    console.log(2)
}
*/

// Scope Closure

/*
function foo() {
    var a = 2;

    function bar() {
        console.log(a);
    }
    bar();
}
foo();
*/

/*
function foo() {
    var a = 2;

    function bar() {
        console.log(a);
    }

    return bar;
}
var baz = foo();
// console.log(baz);
baz(); // observed closure
*/

/*
function foo() {
    var a = 2;

    function baz() {
        console.log(a);
    }

    bar(baz);
}

function bar(fn) {
    fn(); // observed closure
}

foo();
*/

/*
var fn;
function foo() {
    var a = 2;

    function baz() {
        console.log(a);
    }

    fn = baz;
}
function bar() {
    fn();
}
foo();
bar();
*/

/*
function wait(message) {
    
    setTimeout(function timer() {
        console.log(message);
    }, 1000);
}
wait("Hello Closure");
*/

// IIFE is example of observed closure

// Loops and Closures

/*
for (var i = 1; i <= 5; i++) {
    setTimeout(function timer() {
        console.log(i);
    }, i * 1000);
} // output is 6
*/

/*
for (var i = 1; i <= 5; i++) {
    (function () {
        setTimeout(function timer() {
            console.log(i);
        }, i * 1000);
    })();
} // output is 6
*/

/*
for (let i = 1; i <= 5; i++) {
    (function () {
        var j = i;
        setTimeout(function timer() {
            console.log(j);
        }, j * 1000);
    })();
} // works fine
*/

// slight variation of above code

/*
for (let i = 1; i <= 5; i++) {
    (function (j) {
        setTimeout(function timer() {
            console.log(j);
        }, j * 1000);
    })(i);
}
*/

//  with let scoping and closure works hand in hand

/*
for (let i = 1; i <= 5; i++) {
    setTimeout(function timer() {
        console.log(i);
    }, i * 1000);
}
*/

// Modules - code patterns that leverages the power of closures

/*
function foo() {
    var something = "cool";
    var another = [1, 2, 3];

    function dosomething() {
        console.log( something );
    }

    function doAnother() {
        console.log(another.join('!'));
    }
} // both inner func has lexical scope (and thus closure) over inner scope of foo()

// now consider

function coolModule() {
    var something = "cool";
    var another = [1, 2, 3];

    function doSomething() {
        console.log(something);
    }

    function doAnother() {
        console.log(another.join(' ! '));
    }

    return {doSomething:doSomething, doAnother:doAnother};
}

var foo = coolModule();
console.log(foo);
foo.doSomething();
foo.doAnother();

// turning module to IIFE

var foo = (function coolModule() {
    var something = "cool";
    var another = [1, 2, 3];

    function doSomething() {
        console.log(something);
    }

    function doAnother() {
        console.log(another.join(' ! '));
    }

    return {doSomething:doSomething, doAnother:doAnother};
})();
console.log(foo);
foo.doSomething();
foo.doAnother();

// modules are just function which can recieve parameter

function CoolModule(id) {
    function identify() {
        console.log(id);
    }

    return {identify:identify};
}

var foo1 = CoolModule("foo 1");
var foo2 = CoolModule("foo 2");

foo1.identify();
foo2.identify();

// Another powerful variation on module pattern is to name the object you are returning as your public API

var foo = (function CoolModule(id) {
    function change() {
        // modifying public API
        publicAPI.identify = identify2
    }

    function identify1() {
        console.log(id);
    }

    function identify2() {
        console.log(id.toUpperCase());
    }

    var publicAPI = {
        change:change,
        identify:identify1
    };

    return publicAPI;
})("foo module")

console.log(foo);
foo.identify();
foo.change();
foo.identify();
*/

// Modern Modules

/*
var MyModules = (function Manager() {
    var modules = {};

    function define(name, deps, impl) {
        for (var i = 0; i < deps.length; i++) {
            deps[i] = modules[deps[i]];
        }
        modules[name]=impl.apply(impl, deps);
    }

    function get(name) {
        return modules[name];
    }
    
    return {define:define, get:get};
})();

MyModules.define("bar", [], function () {
    function hello(who) {
        return "let me introduce: " + who;
    }

    return {hello:hello};
});

MyModules.define("foo", ["bar"], function (bar) {
    var hungry = "hippo";

    function awesome() {
        console.log(bar.hello(hungry).toUpperCase());
    }

    return {awesome:awesome};
});
var bar = MyModules.get("bar");
var foo = MyModules.get("foo");

console.log(bar.hello("hippo"));

foo.awesome();
*/

// Arrow Function
function wait(message) {
    
    setTimeout(function timer() {
        console.log(message);
    }, 1000);

    setTimeout(() => {
        console.log(message);
    }, 2000);
}
wait("Hello Closure");



</script>
</body>
</html>